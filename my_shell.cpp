#include "parser.h"
#include <iostream>
#include <signal.h>
#include <unistd.h>
#include <termios.h>

using namespace std;

struct termios terminal_backup;

int main()
{
	//initial the shell
    //ignore the signal interrupting shell
    signal (SIGINT, SIG_IGN);//interrupt signal, terminating the process, generated by C-c
    signal (SIGQUIT, SIG_IGN);//quit signal, terminating the process, generated by C-|
    signal (SIGTSTP, SIG_IGN);//stop signal, generated by the SUSP- C-z
    signal (SIGTTIN, SIG_IGN);//require to read from terminal by stopping fg pg
    signal (SIGTTOU, SIG_IGN);//require to output to terminal by stopping fg pg
    //signal (SIGCHLD, SIG_IGN);//when child process stopped or terminated

	int shell_pid = getpid();
	if(setpgid(shell_pid, shell_pid) < 0)
	{
		perror("set shell in its own process group");
	}
	//get control of the terminal
	if(tcsetpgrp(STDIN_FILENO, shell_pid) < 0)
	{
		cout << "tcsetpgrp(shell) fail" <<endl;
		perror("Setting shell foreground process group fails");
	}
    //save current terminal parameters
	tcgetattr(STDIN_FILENO, &terminal_backup);

	char *user_name = getenv("USER");
	char *host_name = new char[30];
	gethostname(host_name, 30);
	string prompt = string(user_name) + "@" + host_name + ":";
	JobManager job_manager;
	Parser parser(job_manager);
	bool running = true;
	while (running)
	{
		string cmd;
		cout<<"\x1b[34m" + prompt + "\x1b[0m" ;
		getline(cin, cmd);
		try {
			parser.parse(cmd);
		}
		catch (ParseError& error) {
			cout << error.error_message << endl;
			continue;
		}
		catch (int i) {
			if (i == 1)
				running = false;
		}
	}
	return 0;
}
